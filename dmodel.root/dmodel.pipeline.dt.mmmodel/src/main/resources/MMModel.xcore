@Ecore(nsPrefix="hcl", nsURI="http://www.example.com/Example")
@GenModel(
    bundleManifest = "false",
    modelDirectory = "src/main/java-gen",
    complianceLevel = "8.0"
)
package dmodel.pipeline.dt.mmmodel

class MeasurementModel {
	contains ResourceEnvironmentData environmentData
	contains UsageData usageData
}

// RESOURCE ENVIRONMENT //
// ____________________ //
class ResourceEnvironmentData {
	String[] hostNames
	contains HostNamePair[] connections
}

class HostNamePair {
	String left
	String right
}

// USAGEMODEL			//
// ____________________ //
class UsageData {
	contains UsageGroup[] groups
}

class UsageGroup {
	long interarrivalTime
	contains IAbstractUsageDescriptor[] descriptors
}

interface IAbstractUsageDescriptor {
	op boolean matches(IAbstractUsageDescriptor other)
	op void merge(IAbstractUsageDescriptor other)
}

class UsageBranchDescriptor extends IAbstractUsageDescriptor {
	contains UsageBranchTransition[] childs
	
	op boolean matches(IAbstractUsageDescriptor other) {
		if (other instanceof UsageBranchDescriptor) {
			if (childs.size == other.childs.size) {
				for (var i = 0; i < childs.size; i++) {
					if (!childs.get(i).matches(other.childs.get(i))) {
						return false
					}
				}
			}
		}
		return false
	}
	
	op void merge(IAbstractUsageDescriptor other) {
		// THIS SHOULD NOT BE DONE
		throw new UnsupportedOperationException
	}
}

class UsageBranchTransition {
	contains IAbstractUsageDescriptor[] childs
	double probability
	
	op boolean matches(UsageBranchTransition other) {
		if (childs.size == other.childs.size) {
			for (var i = 0; i < childs.size; i++) {
				if (!childs.get(i).matches(other.childs.get(i))) {
					return false
				}
			}
		}
		return false
	}
}

class UsageLoopDescriptor extends IAbstractUsageDescriptor {
	int[] iterations
	contains IAbstractUsageDescriptor[] childs
	
	op boolean matches(IAbstractUsageDescriptor other) {
		if (other instanceof UsageLoopDescriptor) {
			if (other.childs.length == childs.length) {
				for (var i = 0; i < childs.length; i++) {
					if (!childs.get(i).matches(other.childs.get(i))) {
						return false;
					}
				}
				return true;
			}
		}
		
		return false
	}
	
	op void merge(IAbstractUsageDescriptor other) {
		if (other instanceof UsageLoopDescriptor) {
			iterations.addAll(other.iterations)
			
			for (var i = 0; i < childs.size(); i++) {
				childs.get(i).merge(other.childs.get(i))
			}
		}
	}
}

class UsageServiceCallDescriptor extends IAbstractUsageDescriptor {
	String serviceId
	contains ParameterValuePair[] parameterValues
	
	op boolean matches(IAbstractUsageDescriptor other) {
		if (other instanceof UsageServiceCallDescriptor) {
			if (other.serviceId.equals(serviceId)) {
				if (other.parameterValues.size == parameterValues.size) {
					// do not check the parameter values
					return true
				}
			}
		}
		return false
	}
	
	op void merge(IAbstractUsageDescriptor other) {
		if (other instanceof UsageServiceCallDescriptor) {
			if (serviceId.equals(other.serviceId)) {
				// merge the parameters
				other.parameterValues.entrySet.forEach[para |
					if (parameterValues.containsKey(para.key)) {
						// add all values
						parameterValues.get(para.key).addAll(para.value)
					} else {
						// easy -> just put it in the map
						parameterValues.put(para.key, para.value)
					}
				]
			}
		}
	}
}

class ParameterValuePair wraps java.util.Map$Entry {
    String key
    Object[] value
}

// SHARED				//	
// ____________________ //	